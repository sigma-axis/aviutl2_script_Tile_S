--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]

@四角タイルσ
--information:四角タイルσ@Tile_S v1.01 (for beta7) by σ軸
--label:カスタムオブジェクト
--track@width:幅,0,4000,320,1
--track@height:高さ,0,4000,320,1
--check@screen_size:背景サイズ,0
--color@col1:色1,0xffffff
--color@col_inner1:内部色1,0x606060
--color@col2:色2,0xe0e0e0
--color@col_inner2:内部色2,0x404040
--color@col3:色3,0xa0a0a0
--color@col_inner3:内部色3,0x000000
--color@col4:色4,0xc0c0c0
--color@col_inner4:内部色4,0x202020
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@alpha4:透明度4,0,100,0,0.01
--track@block_w:マス幅,1,2000,64,0.1
--track@block_h:マス高さ,1,2000,64,0.1
--check@block_square:マス正方形(幅のみで指定),1
--track@line:ライン幅,0,1000,1000,0.1
--track@radius:角半径,0,500,0,0.1
--color@col_back:余白色,0x000000
--track@alpha_back:余白透明度,0,100,100,0.01
--track@back_w:余白幅,0,2000,0,0.1
--track@back_h:余白高さ,0,2000,0,0.1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.01
--track1:Y,-4000,4000,0,0.01
--check@antialias:アンチエイリアス,0
--value@PI:PI,{}
--[[pixelshader@draw:
struct figure {
	float4 color, color_inner;
	float2 outer;
	float line_thick, radius;
};
cbuffer constant0 : register(b0) {
	figure fig[4];
	float4 color_back;
	float2x2 to_lattice;
	float2 offset, size;
	float aa_thick;
};
int2 modf_n(float2 pt, out float2 pt_f)
{
	pt_f = frac(pt);
	return int2(round(pt - pt_f));
}
float4 draw(float4 pos : SV_Position) : SV_Target
{
	float2 pt;
	const int2 pt_i = modf_n(mul(to_lattice, pos.xy - offset), pt);
	const int idx = uint(pt_i.x & 1) | (uint(pt_i.y & 1) << 1);

	pt = min(pt, 1 - pt);

	pt *= size;
	pt -= fig[idx].outer;
	const int idx2 = idx ^ (pt.x < pt.y ? 1 : 2);
	float dist = min(pt.x, pt.y);
	if (max(pt.x, pt.y) < fig[idx].radius) {
		const float r = length(pt - fig[idx].radius);
		dist = min(dist, fig[idx].radius - r);
	}

	return lerp(lerp(fig[idx].color_inner, fig[idx].color,
		smoothstep(-aa_thick / 2, aa_thick / 2, fig[idx].line_thick - dist)),
		fig[idx].radius <= 0 && fig[idx2].radius <= 0 &&
		max(fig[idx].outer, fig[idx2].outer)[pt.x < pt.y ? 0 : 1] <= 0 ?
		fig[idx2].color : color_back,
		smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
}
]]
local obj, tonumber, type, math, bit = obj, tonumber, type, math, require("bit");

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		screen_size:	boolean|number|nil,
		col:			table|number|nil,
		col_inner:		table|number|nil,
		alpha:			table|number|nil,
		block_w:		number?,
		block_h:		number?,
		block_square:	boolean|number|nil,
		line:			table|number|nil,
		radius:			table|number|nil,
		col_back:		number?,
		alpha_back:		number?,
		back_w:			table|number|nil,
		back_h:			table|number|nil,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		antialias:		boolean|number|nil,
	}
--]==]
local function field_as_num(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld] =
			tonumber(t[1]) or tgt[1][fld],
			tonumber(t[2]) or tgt[2][fld],
			tonumber(t[3]) or tgt[3][fld],
			tonumber(t[4]) or tgt[4][fld];
	elseif type(t) == "number" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld] = t, t, t, t;
	end
end
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
local fig = {
	{ line = line, radius = radius, back_w = back_w, back_h = back_h, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col1, col_inner = col_inner1, alpha = alpha1, },
	{ line = line, radius = radius, back_w = back_w, back_h = back_h, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col2, col_inner = col_inner2, alpha = alpha2, },
	{ line = line, radius = radius, back_w = back_w, back_h = back_h, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col3, col_inner = col_inner3, alpha = alpha3, },
	{ line = line, radius = radius, back_w = back_w, back_h = back_h, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col4, col_inner = col_inner4, alpha = alpha4, },
};
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
screen_size = as_bool(PI.screen_size, screen_size ~= 0);
field_as_num(PI, fig, "col");
field_as_num(PI, fig, "col_inner");
field_as_num(PI, fig, "alpha");
block_w = tonumber(PI.block_w) or block_w;
block_h = tonumber(PI.block_h) or block_h;
block_square = as_bool(PI.block_square, block_square);
field_as_num(PI, fig, "line");
field_as_num(PI, fig, "radius");
col_back = tonumber(PI.col_back) or col_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
field_as_num(PI, fig, "back_w");
field_as_num(PI, fig, "back_h");
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
antialias = as_bool(PI.antialias, antialias ~= 0);

-- normalize parameters.
if screen_size then
	width, height = obj.screen_w, obj.screen_h;
else
	width = math.max(math.floor(0.5 + width), 0);
	height = math.max(math.floor(0.5 + height), 0);
end
for i = 1, #fig do
	local f = fig[i];
	f.col = math.floor(0.5 + f.col) % 2 ^ 24;
	f.col_inner = math.floor(0.5 + f.col_inner) % 2 ^ 24;
	f.alpha = math.min(math.max(1 - f.alpha / 100, 0), 1);
	f.line = math.max(f.line, 0);
	f.radius = math.max(f.radius, 0);
	f.back_w = math.max(f.back_w, 0);
	f.back_h = math.max(f.back_h, 0);
end
block_w = math.max(block_w, 1);
block_h = math.max(block_h, 1);
block_square = block_square ~= 0;
col_back = math.floor(0.5 + col_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);
rotate = math.pi / 180 * rotate;
local dx, dy = X + width / 2, Y + height / 2;

-- further calculations.
if block_square then block_h = block_w end
local function rgb(col, alpha)
	return
		alpha * (bit.band(col, 0xff0000) / 0xff0000),
		alpha * (bit.band(col, 0x00ff00) / 0x00ff00),
		alpha * (bit.band(col, 0x0000ff) / 0x0000ff);
end
local function col_pair(l, col_o, col_i, alpha)
	-- remove artifacts when line width is near 0.
	local t = l < 1 and 6 * l / (5 * l + 1) or 1;
	local r_o, g_o, b_o = rgb(col_o, alpha);
	local r_i, g_i, b_i = rgb(col_i, alpha);
	return
		t * r_o + (1 - t) * r_i,
		t * g_o + (1 - t) * g_i,
		t * b_o + (1 - t) * b_i,
		r_i, g_i, b_i;
end
for i = 1, #fig do
	local f = fig[i];
	f.r, f.g, f.b, f.r_i, f.g_i, f.b_i = col_pair(f.line, f.col, f.col_inner, f.alpha);
	f.radius = math.min(f.radius, (block_w - f.back_w) / 2, (block_h - f.back_h) / 2);
	f.back_w, f.back_h = f.back_w / 2, f.back_h / 2;
end
local r_bk, g_bk, b_bk = rgb(col_back, alpha_back);

local m11, m12, m21, m22 do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 = c, s, -s, c;
	m11, m12, m21, m22 = m11 / block_w, m12 / block_w, m21 / block_h, m22 / block_h;
end

-- draw by shader.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.pixelshader("draw", "object", {},
{
	fig[2].r,   fig[2].g,   fig[2].b,   fig[2].alpha;
	fig[2].r_i, fig[2].g_i, fig[2].b_i, fig[2].alpha;
	fig[2].back_w, fig[2].back_h, fig[2].line, fig[2].radius;

	fig[3].r,   fig[3].g,   fig[3].b,   fig[3].alpha;
	fig[3].r_i, fig[3].g_i, fig[3].b_i, fig[3].alpha;
	fig[3].back_w, fig[3].back_h, fig[3].line, fig[3].radius;

	fig[1].r,   fig[1].g,   fig[1].b,   fig[1].alpha;
	fig[1].r_i, fig[1].g_i, fig[1].b_i, fig[1].alpha;
	fig[1].back_w, fig[1].back_h, fig[1].line, fig[1].radius;

	fig[4].r,   fig[4].g,   fig[4].b,   fig[4].alpha;
	fig[4].r_i, fig[4].g_i, fig[4].b_i, fig[4].alpha;
	fig[4].back_w, fig[4].back_h, fig[4].line, fig[4].radius;

	r_bk, g_bk, b_bk, alpha_back;

	m11, m21, 0, 0,
	m12, m22;

	dx, dy; block_w, block_h; antialias and 1 or 0;
});


@三角タイルσ
--information:三角タイルσ@Tile_S v1.01 (for beta7) by σ軸
--label:カスタムオブジェクト
--track@width:幅,0,4000,320,1
--track@height:高さ,0,4000,320,1
--check@screen_size:背景サイズ,0
--color@col1:色1,0xffffff
--color@col_inner1:内部色1,0xa0a0a0
--color@col2:色2,0xe0e0e0
--color@col_inner2:内部色2,0x808080
--color@col3:色3,0xc0c0c0
--color@col_inner3:内部色3,0x606060
--color@col4:色4,0xa0a0a0
--color@col_inner4:内部色4,0x404040
--color@col5:色5,0x808080
--color@col_inner5:内部色5,0x202020
--color@col6:色6,0x606060
--color@col_inner6:内部色6,0x000000
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@alpha4:透明度4,0,100,0,0.01
--track@alpha5:透明度5,0,100,0,0.01
--track@alpha6:透明度6,0,100,0,0.01
--track@block:マス幅,1,2000,64,0.1
--track@line:ライン幅,0,1000,1000,0.1
--track@radius:角半径,0,500,0,0.1
--color@col_back:余白色,0x808080
--track@alpha_back:余白透明度,0,100,100,0.01
--track@back:余白幅,0,2000,0,0.1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.01
--track1:Y,-4000,4000,0,0.01
--check@antialias:アンチエイリアス,1
--value@PI:PI,{}
--[[pixelshader@draw:
struct figure {
	float4 color, color_inner;
	float outer, line_thick, radius;
};
cbuffer constant0 : register(b0) {
	figure fig[6];
	float4 color_back;
	float2x2 to_lattice;
	float2 offset;
	float aa_thick;
};
int2 modf_n(float2 pt, out float2 pt_f)
{
	pt_f = frac(pt);
	return int2(round(pt - pt_f));
}
int modulo3(int x)
{
	return x < 0 ? 2 - (uint(2 - x) % 3) : uint(x) % 3;
}
float4 draw(float4 pos : SV_Position) : SV_Target
{
	float2 pt;
	const int2 pt_i = modf_n(mul(to_lattice, pos.xy - offset), pt);

	const int idx = (pt.x < pt.y ? 1 : 0) | (modulo3(pt_i.x + pt_i.y) << 1);
	int idx2 = +5;

	if (pt.y > pt.x) pt = float2(1 - pt.x, pt.y - pt.x);
	if (pt.x < 2 * pt.y) {
		pt.y = pt.x - pt.y;
		idx2 = +1;
	}
	if (pt.x + pt.y > 1) {
		pt = float2(1 - pt.y, 1 - pt.x);
		idx2 = +3;
	}
	if (2 * pt.x - pt.y > 1) pt.x = 1 - pt.x + pt.y;

	idx2 = uint(idx + idx2) % 6;
	pt -= fig[idx].outer * float2(2.0, 1.0);
	float dist = pt.y;
	if (2 * pt.x - pt.y < fig[idx].radius) {
		const float
			U = pt.x - pt.y - fig[idx].radius / 3, V = pt.x + pt.y - fig[idx].radius,
			r = sqrt(U * U + V * V / 3);
		dist = min(dist, fig[idx].radius / 3 - r);
	}

	return lerp(lerp(fig[idx].color_inner, fig[idx].color,
		smoothstep(-aa_thick / 2, aa_thick / 2, fig[idx].line_thick - dist)),
		fig[idx].radius <= 0 && fig[idx2].radius <= 0 &&
		fig[idx].outer <= 0 && fig[idx2].outer <= 0 ?
		fig[idx2].color : color_back,
		smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
}
]]
local obj, tonumber, type, math, bit = obj, tonumber, type, math, require("bit");

-- set anchors.
obj.setanchor("track", 0, "line");

--take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		screen_size:	boolean|number|nil,
		col:			table|number|nil,
		col_inner:		table|number|nil,
		alpha:			table|number|nil,
		block:			number?,
		line:			table|number|nil,
		radius:			table|number|nil,
		col_back:		number?,
		alpha_back:		number?,
		back:			table|number|nil,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		antialias:		boolean|number|nil,
	}
--]==]
local function field_as_num(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld], tgt[5][fld], tgt[6][fld] =
			tonumber(t[1]) or tgt[1][fld],
			tonumber(t[2]) or tgt[2][fld],
			tonumber(t[3]) or tgt[3][fld],
			tonumber(t[4]) or tgt[4][fld],
			tonumber(t[5]) or tgt[5][fld],
			tonumber(t[6]) or tgt[6][fld];
	elseif type(t) == "number" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld], tgt[5][fld], tgt[6][fld] = t, t, t, t, t, t;
	end
end
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
local fig = {
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col1, col_inner = col_inner1, alpha = alpha1, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col2, col_inner = col_inner2, alpha = alpha2, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col3, col_inner = col_inner3, alpha = alpha3, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col4, col_inner = col_inner4, alpha = alpha4, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col5, col_inner = col_inner5, alpha = alpha5, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col6, col_inner = col_inner6, alpha = alpha6, },
};
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
screen_size = as_bool(PI.screen_size, screen_size ~= 0);
field_as_num(PI, fig, "col");
field_as_num(PI, fig, "col_inner");
field_as_num(PI, fig, "alpha");
block = tonumber(PI.block) or block;
field_as_num(PI, fig, "line");
field_as_num(PI, fig, "radius");
col_back = tonumber(PI.col_back) or col_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
field_as_num(PI, fig, "back");
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
antialias = as_bool(PI.antialias, antialias ~= 0);

-- normalize parameters.
if screen_size then
	width, height = obj.screen_w, obj.screen_h;
else
	width = math.max(math.floor(0.5 + width), 0);
	height = math.max(math.floor(0.5 + height), 0);
end
for i = 1, #fig do
	local f = fig[i];
	f.col = math.floor(0.5 + f.col) % 2 ^ 24;
	f.col_inner = math.floor(0.5 + f.col_inner) % 2 ^ 24;
	f.alpha = math.min(math.max(1 - f.alpha / 100, 0), 1);
	f.line = math.max(f.line, 0);
	f.radius = math.max(f.radius, 0);
	f.back = math.max(f.back, 0);
end
block = math.max(block, 1);
col_back = math.floor(0.5 + col_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);
rotate = math.pi / 180 * rotate;
local dx, dy = X + width / 2, Y + height / 2;

-- further calculations.
local function rgb(col, alpha)
	return
		alpha * (bit.band(col, 0xff0000) / 0xff0000),
		alpha * (bit.band(col, 0x00ff00) / 0x00ff00),
		alpha * (bit.band(col, 0x0000ff) / 0x0000ff);
end
local function col_pair(l, col_o, col_i, alpha)
	-- remove artifacts when line width is near 0.
	local t = l < 1 and 6 * l / (5 * l + 1) or 1;
	local r_o, g_o, b_o = rgb(col_o, alpha);
	local r_i, g_i, b_i = rgb(col_i, alpha);
	return
		t * r_o + (1 - t) * r_i,
		t * g_o + (1 - t) * g_i,
		t * b_o + (1 - t) * b_i,
		r_i, g_i, b_i;
end
for i = 1, #fig do
	local f = fig[i];
	f.r, f.g, f.b, f.r_i, f.g_i, f.b_i = col_pair(f.line, f.col, f.col_inner, f.alpha);
	f.back = math.min((1 / 3 ^ 0.5) * f.back / block, 1);
	f.line = (2 / 3 ^ 0.5) * f.line / block;
	f.radius = math.min((2 * 3 ^ 0.5) * f.radius / block, 1 - 3 * f.back);
end
local r_bk, g_bk, b_bk = rgb(col_back, alpha_back);

local m11, m12, m21, m22 =
	1, 1 / 3 ^ 0.5,
	0, 2 / 3 ^ 0.5 do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
	m11, m12, m21, m22 = m11 / block, m12 / block, m21 / block, m22 / block;
end

-- draw by shader.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.pixelshader("draw", "object", {},
{
	fig[3].r,   fig[3].g,   fig[3].b,   fig[3].alpha;
	fig[3].r_i, fig[3].g_i, fig[3].b_i, fig[3].alpha;
	fig[3].back, fig[3].line, fig[3].radius, 0;

	fig[4].r,   fig[4].g,   fig[4].b,   fig[4].alpha;
	fig[4].r_i, fig[4].g_i, fig[4].b_i, fig[4].alpha;
	fig[4].back, fig[4].line, fig[4].radius, 0;

	fig[1].r,   fig[1].g,   fig[1].b,   fig[1].alpha;
	fig[1].r_i, fig[1].g_i, fig[1].b_i, fig[1].alpha;
	fig[1].back, fig[1].line, fig[1].radius, 0;

	fig[6].r,   fig[6].g,   fig[6].b,   fig[6].alpha;
	fig[6].r_i, fig[6].g_i, fig[6].b_i, fig[6].alpha;
	fig[6].back, fig[6].line, fig[6].radius, 0;

	fig[5].r,   fig[5].g,   fig[5].b,   fig[5].alpha;
	fig[5].r_i, fig[5].g_i, fig[5].b_i, fig[5].alpha;
	fig[5].back, fig[5].line, fig[5].radius, 0;

	fig[2].r,   fig[2].g,   fig[2].b,   fig[2].alpha;
	fig[2].r_i, fig[2].g_i, fig[2].b_i, fig[2].alpha;
	fig[2].back, fig[2].line, fig[2].radius, 0;

	r_bk, g_bk, b_bk, alpha_back;

	m11, m21, 0, 0,
	m12, m22;

	dx, dy; antialias and (2 / 3 ^ 0.5) / block or 0;
});


@六角タイルσ
--information:六角タイルσ@Tile_S v1.01 (for beta7) by σ軸
--label:カスタムオブジェクト
--track@width:幅,0,4000,320,1
--track@height:高さ,0,4000,320,1
--check@screen_size:背景サイズ,0
--color@col1:色1,0xffffff
--color@col_inner1:内部色1,0x404040
--color@col2:色2,0xe0e0e0
--color@col_inner2:内部色2,0x202020
--color@col3:色3,0xc0c0c0
--color@col_inner3:内部色3,0x000000
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@block:マス幅,1,2000,64,0.1
--track@line:ライン幅,0,1000,1000,0.1
--track@radius:角半径,0,500,0,0.1
--color@col_back:余白色,0x808080
--track@alpha_back:余白透明度,0,100,100,0.01
--track@back:余白幅,0,2000,0,0.1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.01
--track1:Y,-4000,4000,0,0.01
--check@antialias:アンチエイリアス,1
--value@PI:PI,{}
--[[pixelshader@draw:
struct figure {
	float4 color, color_inner;
	float outer, line_thick, radius;
};
cbuffer constant0 : register(b0) {
	figure fig[3];
	float4 color_back;
	float2x2 to_lattice;
	float2 offset;
	float aa_thick;
};
int2 modf_n(float2 pt, out float2 pt_f)
{
	pt_f = frac(pt);
	return int2(round(pt - pt_f));
}
int modulo3(int x)
{
	return x < 0 ? 2 - (uint(2 - x) % 3) : uint(x) % 3;
}
float4 draw(float4 pos : SV_Position) : SV_Target
{
	float2 pt;
	const int2 pt_i = modf_n(mul(to_lattice, pos.xy - offset), pt);

	pt.y += modulo3(pt_i.x + pt_i.y);
	int idx, idx2;
	if (pt.x + 1 < pt.y) {
		pt = float2(1.0, 3.0) - pt;
		idx = 2; idx2 = 1;
	}
	else { idx = 0; idx2 = 2; }
	idx = modulo3(pt_i.x + idx);

	if (pt.y > 1) pt = float2(pt.x, 1 + pt.x - pt.y);
	else if (pt.y > pt.x) {
		pt = float2(pt.y, pt.x);
		idx2 = 3 - idx2;
	}
	if (2 * pt.x - pt.y > 1) pt.x = pt.y - pt.x + 1;

	idx2 = uint(idx + idx2) % 3;
	pt -= fig[idx].outer;
	float dist = pt.y;
	if (2 * pt.x - pt.y < fig[idx].radius) {
		const float
			U = pt.x - pt.y, V = pt.x + pt.y - 2 * fig[idx].radius,
			r = sqrt(U * U + V * V / 3);
		dist = min(dist, fig[idx].radius - r);
	}

	return lerp(lerp(fig[idx].color_inner, fig[idx].color,
		smoothstep(-aa_thick / 2, aa_thick / 2, fig[idx].line_thick - dist)),
		fig[idx].radius <= 0 && fig[idx2].radius <= 0 &&
		fig[idx].outer <= 0 && fig[idx2].outer <= 0 ?
		fig[idx2].color : color_back,
		smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
}
]]
local obj, tonumber, type, math, bit = obj, tonumber, type, math, require("bit");

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		screen_size:	boolean|number|nil,
		col:			table|number|nil,
		col_inner:		table|number|nil,
		alpha:			table|number|nil,
		block:			number?,
		line:			table|number|nil,
		radius:			table|number|nil,
		col_back:		number?,
		alpha_back:		number?,
		back:			table|number|nil,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		antialias:		boolean|number|nil,
	}
--]==]
local function field_as_num(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld] =
			tonumber(t[1]) or tgt[1][fld],
			tonumber(t[2]) or tgt[2][fld],
			tonumber(t[3]) or tgt[3][fld];
	elseif type(t) == "number" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld] = t, t, t;
	end
end
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
local fig = {
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col1, col_inner = col_inner1, alpha = alpha1, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col2, col_inner = col_inner2, alpha = alpha2, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col3, col_inner = col_inner3, alpha = alpha3, },
};
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
screen_size = as_bool(PI.screen_size, screen_size ~= 0);
field_as_num(PI, fig, "col");
field_as_num(PI, fig, "col_inner");
field_as_num(PI, fig, "alpha");
block = tonumber(PI.block) or block;
field_as_num(PI, fig, "line");
field_as_num(PI, fig, "radius");
col_back = tonumber(PI.col_back) or col_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
field_as_num(PI, fig, "back");
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
antialias = as_bool(PI.antialias, antialias ~= 0);

-- normalize parameters.
if screen_size then
	width, height = obj.screen_w, obj.screen_h;
else
	width = math.max(math.floor(0.5 + width), 0);
	height = math.max(math.floor(0.5 + height), 0);
end
for i = 1, #fig do
	local f = fig[i];
	f.col = math.floor(0.5 + f.col) % 2 ^ 24;
	f.col_inner = math.floor(0.5 + f.col_inner) % 2 ^ 24;
	f.alpha = math.min(math.max(1 - f.alpha / 100, 0), 1);
	f.line = math.max(f.line, 0);
	f.radius = math.max(f.radius, 0);
	f.back = math.max(f.back, 0);
end
block = math.max(block, 1);
col_back = math.floor(0.5 + col_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);
rotate = math.pi / 180 * rotate;
local dx, dy = X + width / 2, Y + height / 2;

-- further calculations.
local function rgb(col, alpha)
	return
		alpha * (bit.band(col, 0xff0000) / 0xff0000),
		alpha * (bit.band(col, 0x00ff00) / 0x00ff00),
		alpha * (bit.band(col, 0x0000ff) / 0x0000ff);
end
local function col_pair(l, col_o, col_i, alpha)
	-- remove artifacts when line width is near 0.
	local t = l < 1 and 6 * l / (5 * l + 1) or 1;
	local r_o, g_o, b_o = rgb(col_o, alpha);
	local r_i, g_i, b_i = rgb(col_i, alpha);
	return
		t * r_o + (1 - t) * r_i,
		t * g_o + (1 - t) * g_i,
		t * b_o + (1 - t) * b_i,
		r_i, g_i, b_i;
end
for i = 1, #fig do
	local f = fig[i];
	f.r, f.g, f.b, f.r_i, f.g_i, f.b_i = col_pair(f.line, f.col, f.col_inner, f.alpha);
	f.back = math.min((2 / 3 ^ 0.5) * f.back / block, 1);
	f.line = (4 / 3 ^ 0.5) * f.line / block;
	f.radius = math.min((4 / 3 ^ 0.5) * f.radius / block, 1 - f.back);
end
local r_bk, g_bk, b_bk = rgb(col_back, alpha_back);

local m11, m12, m21, m22 =
	1, 1 / 3 ^ 0.5,
	0, 2 / 3 ^ 0.5 do
	local c, s = -math.sin(rotate), math.cos(rotate); -- `rotate` added by pi/2.
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
	m11, m12, m21, m22 = (2 / block) * m11, (2 / block) * m12, (2 / block) * m21, (2 / block) * m22;
end

-- draw by shader.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.pixelshader("draw", "object", {},
{
	fig[3].r,   fig[3].g,   fig[3].b,   fig[3].alpha;
	fig[3].r_i, fig[3].g_i, fig[3].b_i, fig[3].alpha;
	fig[3].back, fig[3].line, fig[3].radius, 0;

	fig[1].r,   fig[1].g,   fig[1].b,   fig[1].alpha;
	fig[1].r_i, fig[1].g_i, fig[1].b_i, fig[1].alpha;
	fig[1].back, fig[1].line, fig[1].radius, 0;

	fig[2].r,   fig[2].g,   fig[2].b,   fig[2].alpha;
	fig[2].r_i, fig[2].g_i, fig[2].b_i, fig[2].alpha;
	fig[2].back, fig[2].line, fig[2].radius, 0;

	r_bk, g_bk, b_bk, alpha_back;

	m11, m21, 0, 0,
	m12, m22;

	dx, dy; antialias and (4 / 3 ^ 0.5) / block or 0;
});


@菱形タイルσ
--information:菱形タイルσ@Tile_S v1.01 (for beta7) by σ軸
--label:カスタムオブジェクト
--track@width:幅,0,4000,320,1
--track@height:高さ,0,4000,320,1
--check@screen_size:背景サイズ,0
--color@col1:色1,0xffffff
--color@col_inner1:内部色1,0x606060
--color@col2:色2,0xe0e0e0
--color@col_inner2:内部色2,0x404040
--color@col3:色3,0xa0a0a0
--color@col_inner3:内部色3,0x000000
--color@col4:色4,0xc0c0c0
--color@col_inner4:内部色4,0x202020
--track@alpha1:透明度1,0,100,0,0.01
--track@alpha2:透明度2,0,100,0,0.01
--track@alpha3:透明度3,0,100,0,0.01
--track@alpha4:透明度4,0,100,0,0.01
--track@block_w:マス幅,1,2000,96,0.1
--track@block_h:マス高さ,1,2000,64,0.1
--track@line:ライン幅,0,1000,1000,0.1
--track@radius:角半径,0,707.12,0,0.1
--color@col_back:余白色,0x000000
--track@alpha_back:余白透明度,0,100,100,0.01
--track@back:余白幅,0,2000,0,0.1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.01
--track1:Y,-4000,4000,0,0.01
--check@antialias:アンチエイリアス,1
--value@PI:PI,{}
--[[pixelshader@draw:
struct figure {
	float4 color, color_inner;
	float outer, line_thick, radius;
};
cbuffer constant0 : register(b0) {
	figure fig[4];
	float4 color_back;
	float2x2 to_lattice;
	float2 offset, size;
	float aa_thick;
};
int2 modf_n(float2 pt, out float2 pt_f)
{
	pt_f = frac(pt);
	return int2(round(pt - pt_f));
}
float4 draw(float4 pos : SV_Position) : SV_Target
{
	float2 pt;
	const int2 pt_i = modf_n(mul(to_lattice, pos.xy - offset), pt);

	const int idx = uint(pt_i.x & 1) | (uint(pt_i.y & 1) << 1);
	int idx2 = idx ^ 2;

	float2 sz2 = size * size;
	float N = sz2.x + sz2.y, D = sz2.x - sz2.y;
	if (pt.x + pt.y > 1) pt = 1 - pt;
	if (pt.x < pt.y) {
		pt = float2(pt.y, pt.x);
		idx2 ^= 3;
	}
	if (N * pt.x + D * pt.y > sz2.x) {
		pt.x = 1 - pt.x;
		sz2 = float2(sz2.y, sz2.x);
		D = -D;
	}

	pt -= fig[idx].outer;
	float dist = pt.y;
	if (N * pt.x + D * pt.y < sz2.x * fig[idx].radius) {
		const float U = pt.x + pt.y - fig[idx].radius, V = pt.x - pt.y,
			r = sqrt((N / 4) * (U * U / sz2.y + V * V / sz2.x));
		dist = min(dist, fig[idx].radius / 2 - r);
	}

	return lerp(lerp(fig[idx].color_inner, fig[idx].color,
		smoothstep(-aa_thick / 2, aa_thick / 2, fig[idx].line_thick - dist)),
		fig[idx].radius <= 0 && fig[idx2].radius <= 0 &&
		fig[idx].outer <= 0 && fig[idx2].outer <= 0 ?
		fig[idx2].color : color_back,
		smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
}
]]
local obj, tonumber, type, math, bit = obj, tonumber, type, math, require("bit");

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		width:			number?,
		height:			number?,
		screen_size:	boolean|number|nil,
		col:			table|number|nil,
		col_inner:		table|number|nil,
		alpha:			table|number|nil,
		block_w:		number?,
		block_h:		number?,
		line:			table|number|nil,
		radius:			table|number|nil,
		col_back:		number?,
		alpha_back:		number?,
		back:			table|number|nil,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		antialias:		boolean|number|nil,
	}
--]==]
local function field_as_num(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld] =
			tonumber(t[1]) or tgt[1][fld],
			tonumber(t[2]) or tgt[2][fld],
			tonumber(t[3]) or tgt[3][fld],
			tonumber(t[4]) or tgt[4][fld];
	elseif type(t) == "number" then
		tgt[1][fld], tgt[2][fld], tgt[3][fld], tgt[4][fld] = t, t, t, t;
	end
end
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
local fig = {
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col1, col_inner = col_inner1, alpha = alpha1, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col2, col_inner = col_inner2, alpha = alpha2, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col3, col_inner = col_inner3, alpha = alpha3, },
	{ line = line, radius = radius, back = back, r = 0.0, g = 0.0, b = 0.0, r_i = 0.0, g_i = 0.0, b_i = 0.0, col = col4, col_inner = col_inner4, alpha = alpha4, },
};
width = tonumber(PI.width) or width;
height = tonumber(PI.height) or height;
screen_size = as_bool(PI.screen_size, screen_size ~= 0);
field_as_num(PI, fig, "col");
field_as_num(PI, fig, "col_inner");
field_as_num(PI, fig, "alpha");
block_w = tonumber(PI.block_w) or block_w;
block_h = tonumber(PI.block_h) or block_h;
field_as_num(PI, fig, "line");
field_as_num(PI, fig, "radius");
col_back = tonumber(PI.col_back) or col_back;
alpha_back = tonumber(PI.alpha_back) or alpha_back;
field_as_num(PI, fig, "back");
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
antialias = as_bool(PI.antialias, antialias ~= 0);

-- normalize parameters.
if screen_size then
	width, height = obj.screen_w, obj.screen_h;
else
	width = math.max(math.floor(0.5 + width), 0);
	height = math.max(math.floor(0.5 + height), 0);
end
for i = 1, #fig do
	local f = fig[i];
	f.col = math.floor(0.5 + f.col) % 2 ^ 24;
	f.col_inner = math.floor(0.5 + f.col_inner) % 2 ^ 24;
	f.alpha = math.min(math.max(1 - f.alpha / 100, 0), 1);
	f.line = math.max(f.line, 0);
	f.radius = math.max(f.radius, 0);
	f.back = math.max(f.back, 0);
end
block_w = math.max(block_w, 1);
block_h = math.max(block_h, 1);
col_back = math.floor(0.5 + col_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);
rotate = math.pi / 180 * rotate;
local dx, dy = X + width / 2, Y + height / 2;

-- further calculations.
local function rgb(col, alpha)
	return
		alpha * (bit.band(col, 0xff0000) / 0xff0000),
		alpha * (bit.band(col, 0x00ff00) / 0x00ff00),
		alpha * (bit.band(col, 0x0000ff) / 0x0000ff);
end
local function col_pair(l, col_o, col_i, alpha)
	-- remove artifacts when line width is near 0.
	local t = l < 1 and 6 * l / (5 * l + 1) or 1;
	local r_o, g_o, b_o = rgb(col_o, alpha);
	local r_i, g_i, b_i = rgb(col_i, alpha);
	return
		t * r_o + (1 - t) * r_i,
		t * g_o + (1 - t) * g_i,
		t * b_o + (1 - t) * b_i,
		r_i, g_i, b_i;
end
local H = 0.5 * block_w * block_h / (block_w ^ 2 + block_h ^ 2) ^ 0.5
for i = 1, #fig do
	local f = fig[i];
	f.r, f.g, f.b, f.r_i, f.g_i, f.b_i = col_pair(f.line, f.col, f.col_inner, f.alpha);
	f.back = math.min(f.back / (4 * H), 0.5);
	f.line = f.line / (2 * H);
	f.radius = math.min(f.radius / H, 1 - 2 * f.back);
end
local r_bk, g_bk, b_bk = rgb(col_back, alpha_back);

local m11, m12, m21, m22 =
	1 / block_w, -1 / block_h,
	1 / block_w, 1 / block_h do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
end

-- draw by shader.
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.pixelshader("draw", "object", {},
{
	fig[2].r,   fig[2].g,   fig[2].b,   fig[2].alpha;
	fig[2].r_i, fig[2].g_i, fig[2].b_i, fig[2].alpha;
	fig[2].back, fig[2].line, fig[2].radius, 0;

	fig[3].r,   fig[3].g,   fig[3].b,   fig[3].alpha;
	fig[3].r_i, fig[3].g_i, fig[3].b_i, fig[3].alpha;
	fig[3].back, fig[3].line, fig[3].radius, 0;

	fig[1].r,   fig[1].g,   fig[1].b,   fig[1].alpha;
	fig[1].r_i, fig[1].g_i, fig[1].b_i, fig[1].alpha;
	fig[1].back, fig[1].line, fig[1].radius, 0;

	fig[4].r,   fig[4].g,   fig[4].b,   fig[4].alpha;
	fig[4].r_i, fig[4].g_i, fig[4].b_i, fig[4].alpha;
	fig[4].back, fig[4].line, fig[4].radius, 0;

	r_bk, g_bk, b_bk, alpha_back;

	m11, m21, 0, 0,
	m12, m22;

	dx, dy; block_w; block_h, antialias and 1 / (2 * H) or 0;
});

